{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh13660\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs28 \cf0 ER-Diagram:\
\

\f1\b0\fs24 In this model, I have 10 different entity sets: Person, Candidate, Voter, County, State, Local Contest, State Contest, National Contest, Contest, and Election. The Voter and Candidate entity sets are subclasses of the Person entity set and inherit the attributes of the Person entity. The open arrows show that a person can be either a candidate, a voter, or both, as candidates can vote for themselves. The Person entity is related to the County entity through the \'93lives_in\'94 relationship, which is a many-to-one relationship with mandatory participation, meaning that every person that exists in the Person entity must live in a county existing in the County entity and that each person can only live in one county, whereas each county can be home to multiple people. The County entity is then related to the State entity through the \'93local_state\'94 relationship, which is a many-to-one relationship as well and also has mandatory participation. Any county existing in the County table must belong to a state and can only belong to one state, whereas a state in the State table can have multiple counties. The County entity and the State entity are both related to Local_Contest and State_Contest through the \'93local_cont\'94 and \'93state_cont\'94 relationships, respectively. Both relationships are many-to-one and have mandatory participation. A local or state contest appearing in the local or state contest tables must be tied to a county or state and can only be tied to one county or state, whereas each county and state can have multiple different contests. \
\
The National Contest, State Contest, and Local Contest entities are subsets of the Contest entity. Every contest must be either a local, state, or national contest. The Voter and Candidate entities are related to the Contest entity through the \'93voted\'94 and \'93runs_in\'94 relationships, respectively. Each of these relationships are many-to-many, as a voter can vote in multiple contests, i.e. local and state contests, and a candidate can run in multiple contests as well. \'93Tally\'94 is a descriptive attribute on the \'93runs_in\'94 relationship and serves to keep track of the number of votes each candidate receives in each contest they run in. Finally, the Election entity is related to the contest entity through the \'93held\'94 relationship, which is a many-to-one relationship with mandatory participation, meaning every contest must be a part of an election and can only be part of one election, while any election can have multiple contests. The \'93voted\'94 relationship serves no other purpose than to keep track of which voters have already voted in which contests, so as to make sure further along the line in the development process that voters can be prevented from voting in the same contest twice. \
\

\f0\b\fs28 Relational Schema:\
\

\f1\b0\fs24 In the relational schema, most of the many-to-one relationships are folded into the many side of the relationship to prevent redundancy. In the ER-diagram, I was able to show participation constraints using the double-line connection but a relational schema is unable to capture this constraint. The many-to-one and many-to-many relationships from the ER-diagram are represented here in the relational schema through the use of primary and foreign keys. For example, in the ER-diagram, the relationship between the Person entity and the County entity was a many-to-one relationship. In the relational schema, this relationship is represented by making the primary key of Person \'93ID\'94 and adding \'93county_id\'94 to Person as a foreign key to County. By doing this, the relational schema can now satisfy the constraint that each person in the Person table can only be associated with one county, while the County table has no reference to specific person id\'92s, and thus can be associated with multiple people. The same concept applies to all other many-to-one relationships translated from the ER-diagram into this relational schema. \
\
Hierarchical relationships from the ER-diagram are represented in this relational schema through the use of foreign keys in hierarchical entities that point towards the primary key of the superclass they belong to. For example, the Voter entity was a hierarchical subclass of Person in the ER-diagram and this relationship is translated over to the relational schema by adding \'93v_id\'94 as a foreign key in the Voter table, referencing the \'93id\'94 primary key in the Person table. This concept applies to all hierarchical classes translated from the ER-diagram to this relational schema. The many-to-many relationships present in the ER-diagram are represented here in the relational schema through the use of foreign keys referencing the appropriate entities. For example, the \'93voted\'94 relationship between the Voter and Contest entities utilizes the foreign keys \'93v_id\'94 and \'93contest_id\'94, referencing Voter and Contest, respectively. Using only foreign keys in these relationships enforces the ability of the relationship to allow multiple voter id\'92s in multiple contests. This concept applies to all many-to-many relationships present in the ER-diagram that are translated into the relational schema. \
\

\f0\b\fs28 SQL DDL:\

\f1\b0 \

\fs24 In my SQL DDL, I was able to directly translate over most of the constraints captured by my relational schema in the form of foreign and primary keys. My DDL primarily identified all the attributes of each entity in the relational schema and pointed out primary keys and foreign keys along with the entities referenced by the foreign keys. While the relational schema was unable to capture the participation constrains present in the ER-diagram, the DDL was able to capture these constraints by setting particular attributes as \'93not null\'94 to enforce participation constraints dictating that every row in the table must have some value for a particular attribute. For example, in the Person entity in the ER-diagram, participation constraints on the relationship with the County entity dictated that any person in the person table must be associated with a county. Using \'93not null\'94 in the DDL for creating this table prevents any person from existing in the Person table without an associated county_id, thus enforcing the constraint that every person in the Person table must have an associated county. This concept applies to all other relationships with participation constraints existing in the ER-diagram that was translated over into a relational schema. \
\

\f0\b\fs28 Voter Application:\
\

\f1\b0\fs24 This application creates an interactive window for the user and allows them to enter their voter ID and view the contests they are eligible to vote in based on the county and state they live in. The code establishes a connection with the univ.db database created with the SQL DDL mentioned above and populated with arbitrary voting-related data for simplicity of use. The user inputs their voter ID and is presented with a \'93See Contests\'94 button that, when clicked, queries the database for contests based on the voter\'92s ID. The query uses the voter\'92s ID to pull the voter\'92s county ID from the Person table and then uses the county ID to pull the corresponding state ID. Based on the state and county IDs, the query pulls in contests from the local contest, state contest, and national contest tables and displays the applicable contests to the voter as clickable buttons. When the voter clicks on a contest button, the query pulls the candidates running in that contest and displays them as clickable buttons for the voter to vote with. The GUI keeps track of which candidate buttons the voter clicks as they vote in each contest and after the voter has voted in every contest, they are presented with a clickable \'93Confirm Votes\'94 button. After the \'93Confirm Votes\'94 button is clicked, the SQL query checks if the combination of candidate and contest already exists in the database. If the combination exists, it updates the tally for the candidate in that contest to include the voter\'92s vote. If it doesn\'92t exist, the query will add a new row to the table.\
\

\f0\b\fs28 Manager Application:\
\

\f1\b0\fs24 This application creates a window to display contest results. It establishes a connection with the univ.db SQLite database containing the updated vote tallies for each candidate in each contest and the query pulls contest descriptions, candidate names, and vote tallies. The query then groups the results by contest and candidate IDs, sorting by contest ID and vote count in descending order. Each candidate in each contest is listed in their contest category along with their corresponding vote counts to the voting \'93manager\'94. \
\
\
\
\
 }